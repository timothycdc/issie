[{"uri":"/issie/verilogComp.html","title":"Verilog Component","content":"\nISSIE Verilog Component\nSyntax\nBoth old and new style syntax are supported.\nOld style example\nmodule decoder(instr,carry,negative,jump,mux1_sel,mux2_sel);\n    input [15:0] instr;\n    input carry,negative;\n    output jump,mux1_sel,mux2_sel;\n\n    wire [3:0] opc = instr[15:12];\n\n    assign jump = opc[0] ? c|n : c\u0026amp;n|op[1]; \n    assign mux1_sel = (\u0026amp;op[3:2]);\n    assign mux2_sel = negative;\n\nendmodule\n\nNew style example\nmodule decoder(\n    input [15:0] instr,\n    input carry,negative,\n    output jump,mux1_sel,mux2_sel\n);\n\n    wire [3:0] opc = instr[15:12];\n\n    assign jump = opc[0] ? c|n : c\u0026amp;n|op[1]; \n    assign mux1_sel = (\u0026amp;op[3:2]);\n    assign mux2_sel = negative;\n\nendmodule\n\nNumbers\nNumbers are given in the form: {width}\u0027{radix}{value}, where radix = \u0027b or \u0027d or \u0027h\ne.g. 16\u0027h3fa5 , 4\u0027b0101, 16\u0027d154\nOperators\nOperators perform an opeation on one or more operands within an expression. An expression combines operands with appropriate operators to produce the desired functional expression.\nThe table shows the operators in descending order of precedence. Operators with equal precedence are shown grouped.\n\n\n\nVerilog Operator\nName\nNotes and example\n\n\n\n\n[ ]\nbit-select or part-select\nUsed to select specific bits of a bus signal. Example: instr[15:8]\n\n\n( )\nparenthesis\nUsed to define the order of operations. Example:  (a \u0026verbar; b) \u0026amp; c\n\n\n!  ~  (\u0026amp;)  (\\|)  (~\u0026amp;)  (~\\|)\nlogical negation  negation  reduction AND  reduction OR  reduction NAND  reduction NOR\nThe Verilog reduction operators are used to convert vectors to scalars. They operate on all of the bits in a vector to convert the answer to a single bit.  AND Reduction of 4\u0027b1101 is: 0  AND Reduction of 4\u0027b1111 is: 1  OR Reduction of 4\u0027b1101 is: 1  OR Reduction of 4\u0027b0000 is: 0  Example: assign out = (\u0026amp;a);\n\n\n{ }\nconcatenation\nExample: {a[2:0],b[3:2],2\u0027b01} -\u0026gt; result is 7 bits\n\n\n\u002B  \u2013\nbinary plus  binary minus\nThe two operands must be of equal width N. The result is also N bits.\n\n\n \u003E\u003E  \u003E\u003E\u003E\nlogical shift left  logical shift right  arithmetic shift right\nThe second operand of a shift is an unsigned integer. Example: assign out[5:0] = in[5:0]  The result has the width of the input.\n\n\n\u0026amp;\nbit-wise AND\nThe two operands must have the same width.\n\n\n^  ~^ or ^~\nbit-wise XOR  bit-wise XNOR\nAs above.\n\n\n\\|\nbit-wise OR\nAs above.\n\n\n\u0026amp;\u0026amp;\nlogical AND\nLogical means that 0-\u0026gt;false, anything else -\u0026gt; true. Operands can have different width.\n\n\n\\|\\|\nlogical OR\nAs above.\n\n\n\n\n| ? : | conditional | Like an if-statement, corresponds to a MUX. Example: assign jump = opc[0] ? c|n : c\u0026amp;n|op[1]; |\n","headings":["ISSIE Verilog Component","Syntax","Old style example","New style example","Numbers","Operators"],"type":"content"},{"uri":"/issie/contact.html","title":"Contact","content":"\nGeneral Issues\nIf you encounter any problems using or downloading the software, please see the Gihub Issue page, or create a new issue on the ISSIE GitHub repository. Any feedback and suggestions are also welcome!\n","headings":["General Issues"],"type":"content"},{"uri":"/issie/userGuide.html","title":"User Guide","content":"\nGetting Started\nDownloading and Running ISSIE\nStart by clicking the download button on the top-right of your screen. This opens the page of the latest release of ISSIE on GitHub. At the bottom of the page, you can find the latest prebuilt binary for your platform (Windows or Macos). Issie will require in total about 200M of disk space.\n\nWindows: unzip *.zip anywhere and double-click the top-level Issie.exe application in the unzipped files.\n\nMacOS: Double click the dmg file  and run the application inside the folder, or drag and drop this to install.\n\nThe binaries are not signed. You will need to perform a one-off security bypass.\n\n\n\nCreating a New Project\nOnce you open Issie you should see two options: New Project and Open Project.\n\nClick New Project\nNavigate to the folder you want to save your project\nEnter the name of your project\nClick Create Project\n\nThis process creates a folder where your project will be stored and the first sheet of your project, called main. You can see this by clicking at the Sheets selection button.\nYour first design\nLet\u0027s start with a very simple schematic: a simple 2-input AND gate.\nAdd the following components to your canvas from the Catalogue tab:\n- INPUT/OUTPUT =\u0026gt; Input =\u0026gt; Name: \u0027A\u0027, Bits: 1\n- INPUT/OUTPUT =\u0026gt; Input =\u0026gt; Name: \u0027B\u0027, Bits: 1\n- GATES =\u0026gt; And\n- INPUT/OUTPUT =\u0026gt; Output =\u0026gt; Name: \u0027OUT\u0027, Bits: 1\nNow make the appropriate wiring to connect all the components by clicking on one port and dragging the wire to the port you want to connect it to.\nConnect:\n- Input \u0027A\u0027 to the first input port of the AND gate\n- Input \u0027B\u0027 to the second input port of the AND gate\n- Output \u0027OUT\u0027 to the output port of the AND gate\nYour design should look like this:\n\nSimulation\nTime to simulate our design and see how the output OUT changes as we change the two inputs.\nClick the Simulation tab which is located on the top-right corner and then Start Simulation. Now you can change the value of the two inputs and see how the value of the output. Try all 4 combinations of inputs:\n- A=0, B=0\n- A=0, B=1\n- A=1, B=0\n- A=1, B=1\nand check that the output is correct based on the truth table of the AND gate.\n\nWell Done! You just completed your first ISSIE design.\nExploiting the ISSIE Features\nA slightly more complex design\nTime to increase the complexity of our design and see how we can exploit the features of ISSIE to create clean and good-looking schematics.\n\nAdd two more inputs named C and D each 1-bit.\nAdd one OR gate and one 2-input MUX\n\nDelete the output OUT\n\nNote: You can delete components and/or wires by selecting them and clicking the delete button on your keyboard\n\n\nAdd a new 1-bit output RESULT\nMake all necessary connections to achieve a diagram like the one bellow:\n\n\nAgain, simulate the design and check the output remains correct as you change the values of the 4 inputs\nImproving the looking of our design\nClearly, this is a terrible and hard to understand design. Let\u0027s improve it! The ISSIE canvas is fully customisable to allow the creation of readable and good-looking schematics. Specifically, we can:\n1. Rotate, Flip and Move around all symbols\n2. Change and Move around the symbols\u0027 labels\n3. Manually route wires as you like\n4. Auto-align elements\n5. Select the wire type we desire (radiussed, jump or modern wires)\nYou can view the shortcuts for all these modifications by clicking on the edit and view menus.\nLet\u0027s now look at our improved schematic:\n\nSummary\n\nIn the Catalogue Menu we can find an extensive and complete library of components (gates, flip-flops, RAMs, ROMs, n-bit registers)\nWe can add any number of components in our sheet and name them as we like\nWhen clicking on a port, ISSIE shows us all the ports we can connect that port to.\nWires are initially automatically routed\nWe can modify our schematic as we like to create a good-looking design.\nWe can simulate our design and check how the outputs change as we change the inputs.\n\nUsing Custom Components\nYour root schematic\nTime now to learn how to use or schematics as cstom components in other design sheets. Here is the idea: The very simple and theoretically useless design we created earlier can be used as a decoder of a 4-bit message to produce a true/false result. Therefore, we are going to create a schematic with an asynchronous-read 4-bit ROM and the schematic we created before as a custom symbol.\nSteps:\n1. Change the name of the current sheet from main to decoder (Sheets -\u0026gt; rename)\n2. Add a new sheet and name it main\n3. Add to the main sheet:\n- Asynchronous ROM (MEMORIES =\u0026gt; ROM (asynchronous)). Select 4 bits addressor, 4 bits data and the Enter data later option\n- Your decoder (THIS PROJECT =\u0026gt; decoder)\n- 1-bit output named \u0027RESULT\u0027 (INPUT/OUTPUT =\u0026gt; Output)\n- 4-bit input named \u0027Addressor\u0027 (INPUT/OUTPUT =\u0026gt; Input)\n4. Using 3 SplitWire components (BUSES =\u0026gt; SplitWire) separate the 4-bit ROM output to 4 1-bit wires. (see image below)\n5. Make the appropriate connections to achieve the schematic below\n\nImproving the design sheet\nIt\u0027s time to use another cool feature of Issie: Moving ports in custom components. Issie allows you to re-order and change the side of input and output ports of custom components by CTRL \u002B CLICKING ON THE PORT you want to move.\nLet\u0027s look how it works in the gif below:\n\nROM Initialisation\nCurrently our ROM is empty as we selected the option Enter Data Later before. Let\u0027s put some values in our ROM.\n\nSelect the ROM and click on the Properties tab\nClick on view/edit memory content\nChange the content of the 16 memory location available by assigning a random 4-bit number to each one\nClick done\n\nSimulation\nSimulate your design! Change the value of the addressor input and see whether your decoder produces a true or false result for each number you assigned to the ROM.\nWaveform Simulation\nCreating a closed loop design\nLet\u0027s now make our top-level design a closed-loop one using a custom addressor which will increment every clock cycle. Now, using the waveform simulator we will be able to view the output of our circuit for all memory locations. In order to create such designs easily, ISSIE offers a Counter component which starting from 0, it increments by one every clock cycle.\nAdd a Counter from the Catalogue (FLIP FLOPS AND REGISTERS). Now select the component and click on Properties. You can select to remove the load and enable ports and give them the default functionality (which is what we want in this case): enable=1; load=0;\nCreate a schematic like the one below:\n\nSimulating your design\nAs soon as you connect everything correctly, You can simulate your design. Click on Simulations and then Wave Simulation.\n\nClick the Start Simulation button\nClick Select Waves\n\nSelect:\n\nAROM1.Dout[3:0]\nREG1.Dout[3:0]\nRESULT: DECODER1.RESULT\n\n\nClick Done\nChange the data to either hex or bin to make them more readable\nCheck that the waveform simulator output matches your previous (Step Simulation) results\n\n\nChanging your design\nNow add an extra register between the counter and the ROM address (or make any other change you want) and check that the simulation has the expected output. You can see the changes in the waveform simulator simply by clicking the refresh button which will be enabled as soon as it detects a change in the schematic.\n\nTruth Table\nOne of ISSIE\u0027s features is the ability to view the truth table for a combinational circuit.\n\nClick on Simulations and then Truth Table\nSelect the DECODER component\nClick on Generate Truth Table button on the \u0027Truth Table for selected logic\u0027 section\nClick on Remove Redundancies\nThuth table should look like this:\n\n\nYou can also select your inputs to be algebraic values to get an expression for each of your outputs.\n\nClick on Back to full table\nClick on Algebra\nSelect the inputs you want to be algebraic values\nTruth table should now look like this:\n\n\nVerilog Component\nLast but not least, ISSIE allows you to create combinational custom components by defining the logic in Verilog. Click on Verilog -\u0026gt; New Verilog Component (Catalogue) and write the logic of your decoder in Verilog.\n\n\nClick Save\nReplace the previous Decoder with the new one (found under Verilog section in the Catalogue)\nSimulate again your design. Everything should be the same as before.\n\nNow what?\nYou now know how to use ISSIE to create \u0026amp; simulate digital designs.\nYou can now create your designs (from simple circuits to fully functionable CPUs) and either simulate them or extract them as Verilog to use them with other tools.\n","headings":["Getting Started","Downloading and Running ISSIE","Creating a New Project","Your first design","Simulation","Exploiting the ISSIE Features","A slightly more complex design","Improving the looking of our design","Summary","Using Custom Components","Your root schematic","Improving the design sheet","ROM Initialisation","Simulation","Waveform Simulation","Creating a closed loop design","Simulating your design","Changing your design","Truth Table","Verilog Component","Now what?"],"type":"content"},{"uri":"/issie/index.html","title":"\u0022Home\u0022","content":"\nRunning Issie\nThe download button on this page take you to the Issie latest release page. Scroll down the top release on this page till you get the the Assets section - this has binaries for windows and macos PCs. Download the appropriate one and unzip it anywhere. No installation is required - Issie runs from the unzipped files under windows if you double-click the top-level Issie.exe file with the blue Issie chip icon. For more information see Getting Started or read the User Guide.\n\nAcknowledgements\n\nMarco Selvatici for the 8K lines of base code written for his 3rd year BEng FYP\nEdoardo Santi for work improving Issie over Summer 2020 and creating the waveform simulator\nHigh Level Programming 2020/21 cohort for providing the base code of the new schematic editor\nJo Merrick for work improving ISSIE for her 3rd year BEng FYP\nHigh Level Programming 2021/22 cohort for implementing a much enhanced schematic editor\nAll 2020/2021 1st year undergraduate students of the EEE department, Imperial College London, for acting as excellent and unpaid beta-testers in their DECA module!\nJason Zheng for improving the waveform simulator for his 4th year MEng FYP\nAditya Deshpande for creating the truth table for his 4th year MEng FYP\nArchontis Pantelopoulos for creating the Verilog Component and improving ISSIE over Summer 2022\nPetra Ratkai and Yujie Wang for imporving the Verilog compiler \u0026amp; Issie simulator in 2022-23.\n\nDr Tom Clarke for running HLP and his continued work maintaining and improving ISSIE throughout\n\n\n\nContact\nIf you encounter any problems using or downloading the software, please see the Gihub Issue page, or create a new issue on the ISSIE GitHub repository. Any feedback and suggestions are also welcome!\n\n","headings":["Running Issie","Acknowledgements","Contact"],"type":"content"},{"uri":"/issie/coolFeatures.html","title":"Features","content":"\nFeatures list\nISSIE provides numerous features to help you create nice and readable schematics. These are analysed in the table below:\n\n\n\nFeature\nHow\nExplanation\n\n\n\n\nChange port location on Custom Components\nPress CTRL and use your mouse to drag a port to another position on the outline of the symbol\nCustom components may end up having a large number of ports. You can move them to your desired location on the outline to create nicer schematics\n\n\nResizing of Custom Components\nChange Width Scale and Height Scale on the properties pane\nIf default sizing makes port legends overlap you can scale custom component width and height in Properties\n\n\nMove component\u0027s label\nSimply drag the component\u0027s label to your desired location on the canvas\n\n\n\nRotate and flip components\nCtrl \u002B left arrow:  Ctrl \u002B right arrow:   Ctrl \u002B up arrow:   Ctrl \u002B down arrow:\nRotate clockwise  Rotate anti-clockwise  Flip vertically  Flip horizontally\n\n\nTruth Table for combinational logic\nSimulations -\u0026gt; Truth Table\nView the truth table for a combinational logic circuit. This can be either a full sheet or a sub-set by selecting the components you want to be included in the truth table\n\n\nAdd a description on your sheets\nDe-select all components and click on properties. Click the Add Description button\nSheet description will appear on the sheet list as an \u0026#9432; button and will be displayed on properties when that sheet is used as a custom component\n\n\nThemes\nView -\u0026gt; Theme\nChoose between the 3 supported themes: Grayscale, Light or Colourful\n\n\nGrid\nView -\u0026gt; Toggle grid\nChoose whether you want the grid to appear on your sheets\n\n\nWire Type\nView -\u0026gt; Wire Type\nChoose between the 3 supported wire types: Jump, Radiussed or Modern wires\n\n\nWire Arrows\nView -\u0026gt; Toggle Wire Arrows\nChoose whether you want arrows at the end-points of your wires to demonstrate the direction of signals\n\n\nAuto-routing\n\nIssie will nearly always route and separate all schematic connections neatly with no manual routing required.\n\n\n\n\n","headings":["Features list"],"type":"content"},{"uri":"/issie/ReadMeCodeAnalysis.html","title":"DrawBlock Analysis\n","content":"\nDrawBlock Analysis\nSheet\nSymbol Alignment\nThis allows symbol edges to stick to other symbol edges when moving them in ISSIE. As it stands it calculates the edges of all the symbols in the sheet then the margins between the these edges and the clicked component. These margins are added to the legacy code that snaps to grid lines. There is an obvious question / issue about the performance especially as the number of symbols increases as well as the usability of the program if there are continuous snappings whenever a component is moved. To reduce this the margin for snapping is reduced (also eliminating an issue where a component would snap with a large gap between itself and other edge) and only distinct edges are used to calculate margins. The critical section in the algorithm is the checkForSnap1D process, previously O(1) as only grid lines were used, now O(n) with n being the number of distinct symbol edges. Our potential performance issue therefore could be reduced by limiting the number of margins added to the function which could be done by only taking nearby components. There is also room to scale this for moving multiple components by using the furthest edges on each side for the unit as a whole.\nBuswire\nManual routing\nManual routing has been fully reworked to have the following behaviour:\n\nA non-binding segment can be dragged anywhere\nA binding segment cannot be dragged past the nubLength of the wire, which is the minimum length of the nubs coming out of the ports (defined as static member nubLength = 8.0 in Wire type)\n\nA segment is defined as binding for a particular port if it is the first segment of non-zero length perpendicular to the port\u0027s nub. See the diagram below for examples:\n\nAuto-route\nAuto-routing is done in 3 stages:\n\nNormalise the routing problem so that the output port is facing right\nGenerate the initial segment list\nRotate the problem back to it\u0027s in the original orientation\n\nInitial Segment List\nSegments are generated based off of the two ports for each wire, with the assumption that the output port is always facing right. The orientation of the input port is checked as well as its relative position to the output port, allowing us to generate an initial segment list. This segment list consists of a small \u201Cnub\u201D segment immediately joining the input and output port. These are followed by 0 length segments in order to facilitate previous functionality of ISSIE where we could drag wires fully. After these 0 length segments we create the remaining segments to link the two ports. These distances are either set to halfway between the two ports, or a small distance in order to get past the boundaries of a symbol.\nPartial Auto-routing\nPartial auto-routing attempts to preserve any manual routing when symbols (and their ports) are moved. The conditions for this preservation is as follows:\n\nFor a given port being moved, the fixed point is defined as the end of the first manual segment, traversing the wire from the port being moved.\nIf the moved port is in the same quadrant relative to the fixed point, manual routing is preserved by scaling the segment containing the fixed point and the one preceding it by the appropriate XY offset.\nElse, we revert to full auto-routing.\n\nSee the diagram below for an example of the region where partial auto-routing will be applied:\n\nSmart auto-routing\nFollowing the discussion during the project demonstration, the following section has been added to detail the design philosophy around smart auto-routing. Implementing smart auto-routing was considered, and after some exploratory discussions was ultimately rejected. It is of critical importance that a smart auto-routing implementation does not cause un-intutive behaviour for routing problems (i.e. either it works well or it does nothing). Although a heuristic based approach could work well for simple cases, and could be disabled for complex ones, despite this however, we felt as though this approach was not forward thinking. A complete routing solution, involving a pathfinding algorithm like A* or Dijkstra\u0027s, was considered to be the ideal approach. This would require completely rewriting the current routing logic, which is non-trivial, particularly for a project of this scope. We felt as though building on the complexity of the current implementation would make re-writing the autorouting more difficult for future maintenance and updates of the code.\nRadial wires\nRadial wires are one of the wire types selectable in the view menu, which shows if wire are connected by having a curve. The default radius for these curves is defined as static member radius = 5.0 in Wire type. However, for very small wires, this radius is changed to prevent visual bugs. When drawing radii, the length of the smallest segment the curve connects to is checked, and if its length is \u0026lt;5, the radius is shrunk to match it. Due to the limitations of drawing Arcs in SVG, these radii can only be integer valued, leading to small inconsistencies when a segment is a small non integer value (i.e. 1.5).\nSymbols\nAuto-sizing\nCustom components are dynamically resized depending on their port configuration. The minimum distance distance between 2 ports is set as GridSize = 30, which is defined as a [\u0026lt;Literal\u0026gt;] at the top of Symbol.fs. The dimensions of a component are determined as follows:\n\nHeight: Determined purely from the maximum number of ports on the left or right edge (n), setting the height to (n\u002B1)GridSize, and spreading the ports GridSize apart.\nWidth: The distance between ports is determined by the maximum between the largest port label and GridSize. This ensures that the labels of the ports cannot overlap, whilst still being a minimum distance apart. The width can be calculated for both the Top and Bottom edges using the same approach as above using the maximum value, and taking the largest of these 2 values. In addition, the length of the longest labels from the Left and Right sides, as well as the component label (displayed in the center of the component) are added up and compared to the width obtained from the previous calculation. By selecting the component width as the maximum of these values, it can be ensured that labels associated with the component / ports do not overlap.\n\nCustom components\u0027 ports can be placed to different edges on the Symbol by pressing Ctrl and dragging the port.\nWhen a port is dragged onto a different edge, the width and height of the component is automatically resized. The ports on one edge are always equidistant. The height of the component is determined purely from the number of ports on the left or right edge, depending on which one has more ports. The width of the component also considers the lengths of the ports on the top and bottom edges. The distance between ports on the top and bottom edges is big enough, such that it can fit the longest portlabel on the edge, but never smaller than 1 gridsize. The necessary width of the top/bottom edge is determined from this distance and from the number of ports on this edge. The width of the component is given by either the top or bottom edge width, whichever is bigger.\nPort placement\nThe ordering of the ports is represented by their index in the list associated to a particular edge of the Symbol (Top, Left, Bottom, Right). We allow ports to be moved for custom components by clicking and dragging the port while holding down the Ctrl key. When a port is dropped, the target index is determined from it\u0027s position along an edge, (in a process inverse to how the position of the port is calculated based on its index). The port is then removed from its old list, and inserted into the target index of the new list. This also allows the order of ports on the same edge to be re-arranged, by simply removing it and inserting it into the same list.\nSymbol Drawing\nThe function rotatePoints is a useful function that allowed us to avoid the hassle of endless match statements when drawing the react element for the shape outline. It can take a set of points (which usually map to the points needed to draw the shape) and rotate them about the centre of a shape depending on the transformations applied to the shape (flipped / rotated) without additional storage for the current points / transformation history. To achieve this it uses a small hack so that while a shape is flipped a rotateLeft cmd will tell the points to rotate right. This is a limitation of the function as it always performs any rotation then flipping first. This was needed because a flip then rotation 90\u0026deg; clockwise is not necessarily equivalent to a rotation 90\u0026deg; clockwise then flip. However a flip then rotation 90\u0026deg; clockwise is equivalent to a rotation 90\u0026deg; anti-clockwise then flip.\nNew ISSIE Components\nThe Mux4, Mux8, Demux4 and Demux8 components have been implemented as new ISSIE components. A few issues were encountered when doing this:\n\nRendering issues: The new components have different shapes compared to Mux2 and Demux2 so getMuxSelOffset was modified to return correct offset depending on the component.\nSelect bit issues: Originally, the extractBit function has an assertion to ensure the select input only has a width of 1. However, there is now a possibility of select inputs of width 2 or 3, so a busWidth parameter was added for the width size of select.\nLogic issues: The match statements for all the different widths need to be covered, outputting an error if there is a width mismatch for the inputs.\n\nThe new components were tested in 2 ways:\n\nNew components were generated and checked if they are rendered properly by applying a combination of flips and rotates on the components.\nDifferent combinations of inputs were tested in simulation, ensuring that the output produces the correct value. Input combinations were not tested exhaustively due to the sheer number of combinations (particularly for the MUX/DEMUX8), but sufficient tests were performed until a high degree of confidence was achieved.\n\n","headings":["DrawBlock Analysis","Sheet","Symbol Alignment","Buswire","Manual routing","Auto-route","Initial Segment List","Partial Auto-routing","Smart auto-routing","Radial wires","Symbols","Auto-sizing","Port placement","Symbol Drawing","New ISSIE Components"],"type":"content"},{"uri":"/issie/updates/2021-07-04-Issie-v2-1-0.html","title":"ISSIE v2.1.0","content":"\nISSIE v2.1.0\nIntroduction\nIssie came about when we were working out the coursework for a combined two-Term 1st year Digital Electronics and Computer Architecture module in the Electronic and Electrical Engineering Department, Imperial College London. For those interested it is Elec40003. We wanted coursework for introductory Digital Electronics, that would scale to simple CPU design, with hierarchical block schematic based design entry. We considered an HDL, and decided this was less intuitive and in any case the extra time learning an HDL could be better used. Schematics help in visualising signal flow and hierarchy - key concepts when first learning digital Electronics. There is also a strong case for preferring block schematic representation for the top-level structural levels of a design, even if the design is all written in an HDL.\nUpdates\nIt is now, v2.1.0, one year from when Issie was first created, and it has survived three terms of heavy use by 1st year undergraduates. The final working student designs, implemented from scratch with no pre-built blocks, were dual-core CPUs with cut-down ARM-like instruction set, UARTs, and IEEE 754 single precision FPUs. Designs were can output as Verilog and synthesised on FPGAs or (as additional validation) simulated with a Verilog simulator.\nThe original design created by Marco Selvatici (3rd year EEE student) has stood quite well, with two major changes:\n\nSimulation. the original (very clever) recursive functional simulator proved to be incapable of correctly representing circuits with complex subsheets that contain clocked and combinational logic. Also it was very slow. So we wrote, under pressure of student complex designs not quite working, a new simulator. This flattened the hierarchical design to a sea of Issie components and then determined a feasible fixed execution order for all components. It proved robust and also much, much, faster than the original simulation. Both of these qualities were needed!\nDrawing library. Issie originally depended on Draw2D - a big and very sophisticated Javascript draw library. The schematic editor used this and added custom (Javascript) digital component symbols. However the wire auto-router in this library that we wanted to use proved to be buggy (it would crash) and it was not easy to mend because the crash was an infinite loop through a lot of complex Draw2D repainting code. A completely new custom drawing library designed specifically for Issie was written by 3rd year students in EEE, and integrated with Issie. This was debugged through Summer Term issue usage and is now more usable than the original Draw2D library. This rewrite has a lot of advantages - the application is now all F#, the draw library is written as a fully MVU (Elm-like) web-style application without internal state, and the complete draw library is now much faster than the old Javascript one.\n\nThese changes and some other minor additions have pushed the code base from 8K lines F# to 17K lines. F# is a very concise language, so that is a significant program.\nIssie is run as an open source project but thus far all serious development has been internal to Imperial College London, from staff and students. We are now hoping that other people will be interested!\n","headings":["ISSIE v2.1.0","Introduction","Updates"],"type":"content"},{"uri":"/issie/updates/2022-05-04-Issie-v3-0-0.html","title":"ISSIE v3.0.0","content":"\nISSIE v3.0.0\nOne year on and Issie has survived another year of intensive testing by EEE students with, this time, no significant bugs!\nThis Summer we have some significant upgrades, described below. With these, Issie is now up to 24K lines of F#!\nNew Schematic Editor: v3.0.0\nThe initial schematic editor could only autoroute from right edge outputs to left edge inputs. That was quite limiting and we were finding that with no ability to rotate or flip components designs were often badly routed. We partly fixed this by allowing custom component (subsheet instance) ports to be arbitrarily positioned but the UI for this was unpleasant and required chnaging component poistions on the underlying sheet.\nSo this year the HLP students were set the task of improving the schemetic editor, allowing arbitrary auto-routing, component rotating and flipping, MUXes with select inputs on a different edge from outputs and inputs. As is often the case they exceeded this brief and in v3.0.0 we have their work put together and tidied up, with very many enhancements over v2.\nPolishing: v3.0.0\nLittle things for usability, like recent project lists and a persistent load/save directory, have been implemented for greater usability, and all minor bugs except for waveform simulator top-level UI weirdness have been closed. The waveform simulator is currently being overhauled, hence its top-level UI will be part of that.\nWaveform Simulator\nThe code here is very complex and difficult to work with. It is being re-implemented with the idea that we can make it more interactive and add functionality. Since this is a student\u0027s project work the end result is still not clear! Expect results released in early July.\nStep Simulator\nThe step simulator is being reworked with some added feaures (another student project). Again exact functionality is still under consideration: expect results released in early July.\nLooking forward\nOver the Summer we hope for two major improvements:\n\nVerilog components. We will implement a verilog (subset) parser and allow at least combinational Verilog blocks as components.\nParametrised sheets. Library components in Issie are currently limited by the lack of sheet-level parameters (for example bus width). We would like to implement this so that complex components can be implemented as libraries.\n\nHave a look at the issues and associated discussions for where we are on these two projects - contribute if you are interested or have strong requirements.\n","headings":["ISSIE v3.0.0","New Schematic Editor: v3.0.0","Polishing: v3.0.0","Waveform Simulator","Step Simulator","Looking forward"],"type":"content"},{"uri":"/issie/updates/2022-09-20-Issie-v3-0-1.html","title":"ISSIE v3.0.1","content":"\nISSIE v3.0.1\nThe Summer has been highly productive for Issie, with work from Jason, Aditya, and Archontis - whose time working on a 6 month placement has been invaluable. I am very grateful for their help.\nWe have added another 11K lines of code to Issie. This comprises many new features, but also a lot of work to fix bugs and reduce technical debt. Part of this is\nwhat you might call user interface technical debt. As new features are added some of the initial UI design elements no longer work intuitively and so they must be reworked. This was true for the waveform simulation. We now have a redesigned user interface where step\nsimulation and waveform simulation work the same way and enhance each other. In addition the waveform Viewer now works without limitations on very large designs and allows design correction and resimulation\nwithout losing the simulation context. This should significantly speed up edit/debug cycles on larger designs.\nTwo other notable developments implemented by Archontis.\n\n\nWe have an initial Verilog entry window to allow complex combinational logic to be written as equations. Although the current impelmentation is a subset of\nVHDL it has two merits: the user in-editor error messages are instant and very understandable, and the parsing logic is implemented using a Nearley Parser. Nearley grammars are powerful and easy to write, they\nalso make it easy to get detailed and precise error messages from the parse - that is needed for a user-friendly Verilog entry system! Expanding Verilog input to the full language will be a future project, this is a secure foundation.\n\nWe have completed the interface to Issie stick hardware so that designs can be run on FPGAs and debugged (with Issie as debugger).\n\nFor me the most interesting take home has been the ease with which even a fairly large design (now 36K lines of F# in 60 files) can be reworked. This is a merit of the \u0022near functional\u0022 architecture using F# and Elmish MVU. Problems with technical debt have come from original code that breaks the Issie guidelines, or where requirements have changed so much that significant redesign is needed.\nTechnically, most interesting was integrating a Javascript Nearley parser, and adding Optics to make the syntax for nested state changes more readable. For users, we have a lot of little features and UI improvements too numerous to mention here that fill gaps in Issie making it a better CAD tool while keeping its extreme simplicity.\nWe are reasonably confident that the changes will make an even better experience for the new EEE 1st year DECA students!\nLooking forward: the two major improvements now wanted are a faster simulator more capable in big designs, and a complete Verilog language implementation.\nTom Clarke, September 2022\n","headings":["ISSIE v3.0.1"],"type":"content"},{"uri":"/issie/updates/2022-12-25-Issie-v3-0-9.html","title":"ISSIE v3.0.9  - Happy Christmas!","content":"\nISSIE v3.0.9  - Happy Christmas!\nHappy Christmas and New Year to all Issie users!\nThe major changes from last year have now survived Autumn Term testing with a few minor changes and fixes to improve the all-new waveform simulation display. Next term will have more serious user testing with a few hundred students using the waveform simulator to run and debug a multi-sheet EEP1 CPU.\nFor the period of the Spring term there will be no new features - and bug fixes as needed. We hope not many will be needed.\nThis year the main Issie improvement will be the simulator, where 0x6770 (Yujie Wang) is working on a branch that will use a variety of techniques to speed up simulation by a large amount. Yujie will also be making a few additions to the recommended Issie tool chain and style guide.\nIn addition a major extension is expected to the current simple Verilog component feature. Petra Ratkai petraratkai is working on a much more complete Verilog compiler that will move Issie more towards non-schematic use. The hope is that eventually for advanced work schematics can be used for structural code an top-level hierarchy, and RTL modules implemented in HDL.\nTom Clarke, December 2022\n","headings":["ISSIE v3.0.9  - Happy Christmas!"],"type":"content"}]